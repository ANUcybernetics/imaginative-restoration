import type { Fn, NumericArray } from "@thi.ng/api";
import type { ReadonlyVec } from "@thi.ng/vectors";
import type { IDistance, Metric } from "./api.js";
/**
 * Takes a vector `p`, array of `samples` and a `dist`ance function. Computes
 * and returns index of the sample closest to `p` (according to `dist`, default:
 * {@link DIST_SQ}).
 *
 * @reference
 * Use {@link argminT} for non-vector inputs.
 *
 * https://en.wikipedia.org/wiki/Arg_max#Arg_min
 *
 * @param p -
 * @param samples -
 * @param dist -
 */
export declare const argmin: (p: ReadonlyVec, samples: ReadonlyVec[], dist?: Metric<ReadonlyVec> | IDistance<ReadonlyVec>) => number;
export declare const argminN: (p: number, samples: NumericArray, dist?: Metric<number> | IDistance<number>) => number;
/**
 * Similar to {@link argmin}, but for non-vector inputs and taking an additional
 * `key` function. Applies `key` to each item (incl. `p`) to obtain its vector
 * representation, then computes and returns index of the sample closest to `p`
 * (according to `dist`).
 *
 * @reference
 * Use {@link argmin} if all items are vectors already.
 *
 * @param p -
 * @param samples -
 * @param key -
 * @param dist -
 */
export declare const argminT: <T>(p: T, samples: T[], key: Fn<T, ReadonlyVec>, dist?: Metric<ReadonlyVec> | IDistance<ReadonlyVec>) => number;
/**
 * Similar to {@link argmin}, but for k-nearest queries.
 *
 * @param k -
 * @param p -
 * @param samples -
 * @param dist -
 */
export declare const argminK: (k: number, p: ReadonlyVec, samples: ReadonlyVec[], dist?: IDistance<ReadonlyVec>) => number[];
/**
 * Similar to {@link argminT}, but for k-nearest queries.
 *
 * @param k -
 * @param p -
 * @param samples -
 * @param dist -
 */
export declare const argminKT: <T>(k: number, p: T, samples: T[], key: Fn<T, ReadonlyVec>, dist?: IDistance<ReadonlyVec>) => number[];
//# sourceMappingURL=argmin.d.ts.map