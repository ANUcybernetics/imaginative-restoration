import type { IDeref } from "@thi.ng/api";
import { Heap } from "@thi.ng/heaps/heap";
import type { ReadonlyVec } from "@thi.ng/vectors";
import type { IDistance, INeighborhood, Neighbor } from "./api.js";
/**
 * A {@link INeighborhood} implementation for K-nearest neighbor queries around
 * a given target location, initial query radius and {@link IDistance} metric to
 * determine proximity. See {@link Radial} for an unbounded and unsorted
 * version.
 *
 * @remarks
 * The K-nearest neighbors will be accumulated via an internal
 * [`Heap`](https://docs.thi.ng/umbrella/heaps/classes/Heap.html) and results
 * can be optionally returned in order of proximity (via {@link KNearest.deref}
 * or {@link KNearest.values}). For K=1 it will be more efficient to use
 * {@link Nearest} to avoid the additional overhead.
 *
 * @typeParam D - spatial position for distance metric
 * @typeParam T - indexed value
 */
export declare class KNearest<D, T> implements INeighborhood<D, T>, IDeref<Neighbor<T>[]> {
    readonly dist: IDistance<D>;
    target: D;
    k: number;
    radius: number;
    sorted: boolean;
    protected _currR: number;
    protected _heap: Heap<Neighbor<T>>;
    constructor(dist: IDistance<D>, target: D, k: number, radius?: number, sorted?: boolean);
    reset(): this;
    /**
     * Resets search/reference position.
     *
     * @param target
     */
    setTarget(target: D): void;
    /**
     * Resets max. search/query radius and clears current results.
     *
     * @param r
     */
    setRadius(r: number): void;
    /**
     * Resets `k-nearest` limit and clears current results.
     *
     * @param k
     */
    setK(k: number): void;
    /**
     * Returns an array of current nearest neighbor result tuples (each `[dist,
     * val]`). The array will contain at most `k` items and if the `sorted` ctor
     * arg was true, will be sorted by distance.
     *
     * @remarks
     * Use {@link KNearest.values} to obtain result values **without** their distance
     * metrics.
     */
    deref(): Neighbor<T>[];
    /**
     * Similar to {@link KNearest.deref}, but returns array of result values **without**
     * their distance metrics.
     */
    values(): T[];
    includesDistance(d: number, eucledian?: boolean): boolean;
    includesPosition(pos: D): boolean;
    consider(pos: D, val: T): number;
}
/**
 * Defines a {@link KNearest} instance for arbitrary length vector positions
 * and, by default, using an infinite region radius and {@link DIST_SQ} distance
 * metric.
 *
 * @param p -
 * @param k -
 * @param r -
 * @param dist -
 * @param sorted -
 */
export declare const knearest: <T>(p: ReadonlyVec, k: number, r?: number, dist?: import("./squared.js").Squared<ReadonlyVec>, sorted?: boolean) => KNearest<ReadonlyVec, T>;
/**
 * Defines a {@link KNearest} instance for 2D vector positions and, by default,
 * using an infinite region radius and {@link DIST_SQ2} distance metric.
 *
 * @param p -
 * @param k -
 * @param r -
 * @param dist -
 * @param sorted -
 */
export declare const knearest2: <T>(p: ReadonlyVec, k: number, r?: number, dist?: import("./squared.js").Squared<ReadonlyVec>, sorted?: boolean) => KNearest<ReadonlyVec, T>;
/**
 * Defines a {@link KNearest} instance for 3D vector positions, by default,
 * using an infinite region radius and {@link DIST_SQ3} distance metric.
 *
 * @param p -
 * @param k -
 * @param r -
 * @param dist -
 * @param sorted -
 */
export declare const knearest3: <T>(p: ReadonlyVec, k: number, r?: number, dist?: import("./squared.js").Squared<ReadonlyVec>, sorted?: boolean) => KNearest<ReadonlyVec, T>;
/**
 * Defines a {@link KNearest} instance for numeric positions and, by default,
 * using an infinite region radius and {@link DIST_SQ1} distance metric.
 *
 * @param p -
 * @param k -
 * @param r -
 * @param dist -
 * @param sorted -
 */
export declare const knearestN: <T>(p: number, k: number, r?: number, dist?: import("./squared.js").Squared<number>, sorted?: boolean) => KNearest<number, T>;
//# sourceMappingURL=knearest.d.ts.map