import type { Comparator, Fn, IClear, ICopy, IEmpty, ILength, IStack, Maybe, Predicate, Predicate2 } from "@thi.ng/api";
import type { HeapOpts } from "./api.js";
export interface Node<T> {
    v?: T;
    c: Node<T>[];
    p?: Node<T>;
}
export declare const defPairingHeap: <T>(values?: Iterable<T> | null, opts?: Partial<HeapOpts<T>>) => PairingHeap<T>;
export declare class PairingHeap<T> implements Iterable<T>, IClear, ICopy<PairingHeap<T>>, IEmpty<PairingHeap<T>>, ILength, IStack<T, T, PairingHeap<T>> {
    protected compare: Comparator<T>;
    protected equiv: Predicate2<T>;
    protected root: Node<T>;
    protected _size: number;
    constructor(vals?: Iterable<T> | null, opts?: Partial<HeapOpts<T>>);
    get length(): number;
    [Symbol.iterator](): Generator<T, void, unknown>;
    clear(): void;
    empty(): PairingHeap<T>;
    copy(): PairingHeap<T>;
    push(v: T): this;
    pop(): T | undefined;
    pushPop(x: T): T | undefined;
    peek(): T | undefined;
    into(vals: Iterable<T>): this;
    find(val: T): Maybe<T>;
    findWith(fn: Predicate<T>): Maybe<T>;
    has(val: T): boolean;
    /**
     * Computes union with given heap and clears `heap`, i.e. this heap
     * will take ownership of `heap`'s items (if any).
     *
     * @param heap -
     */
    meld(heap: PairingHeap<T>): this;
    visit(fn: Fn<T, boolean>): void;
    protected doVisit(fn: Fn<T, boolean>, root: Node<T>): boolean;
    protected merge(a: Node<T>, b: Node<T>): Node<T>;
    protected mergePairs(heaps: Node<T>[]): Node<T>;
}
//# sourceMappingURL=pairing.d.ts.map