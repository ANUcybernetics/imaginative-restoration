import type { Fn3, FnN7, FnU4, FnU5 } from "@thi.ng/api";
import type { MultiVecOpImpl, ReadonlyVec } from "@thi.ng/vectors";
/**
 * Returns classifier for point `p`, relative to infinite 2D line defined by
 * point `a` and line direction `dir`. one of the following:
 *
 * - 0 if `p` lies on the line (using `eps` as tolerance)
 * - -1 if `p` is right (clockwise) of the line segment
 * - +1 if `p` is left (counterclockwise) of the line segment
 *
 * @param p
 * @param a
 * @param dir
 * @param eps
 */
export declare const classifyPointLine2: (p: ReadonlyVec, a: ReadonlyVec, dir: ReadonlyVec, eps?: number) => 0 | 1 | -1;
/**
 * Syntax sugar for {@link classifyPointLine2}, using points `a` and `b`
 * defining the line segment.
 *
 * @param p
 * @param a
 * @param b
 * @param eps
 */
export declare const classifyPointSegment2: (p: ReadonlyVec, a: ReadonlyVec, b: ReadonlyVec, eps?: number) => 0 | 1 | -1;
/**
 * Returns true if point `p` lies on the line segment `a`, `b`, using `eps` as
 * tolerance.
 *
 * @param p
 * @param a
 * @param b
 * @param eps
 */
export declare const pointInSegment: (p: ReadonlyVec, a: ReadonlyVec, b: ReadonlyVec, eps?: number) => boolean;
/**
 * Same as {@link pointInSegment}, but for polylines/polygons.
 *
 * @param p
 * @param points
 * @param closed
 * @param eps
 */
export declare const pointInSegments: (p: ReadonlyVec, points: ReadonlyVec[], closed: boolean, eps?: number) => boolean;
/**
 * Returns true if point `p` is inside the circle defined by `pos` and `r`.
 *
 * @param p
 * @param pos
 * @param r
 */
export declare const pointInCircle: (p: ReadonlyVec, pos: ReadonlyVec, r: number) => boolean;
export declare const pointInSphere: (p: ReadonlyVec, pos: ReadonlyVec, r: number) => boolean;
/**
 * Returns classifier for `p` regarding the circle defined by `pos` and `r`.
 * Returns -1 if point is outside, 0 if on the boundary (using `eps` as
 * tolerance) or +1 if inside the circle.
 *
 * @remarks
 * Also see {@link pointInCircle}, {@link pointIn3Circle}.
 *
 * @param p
 * @param pos
 * @param r
 * @param eps
 */
export declare const classifyPointInCircle: (p: ReadonlyVec, pos: ReadonlyVec, r: number, eps?: number) => 0 | 1 | -1;
/**
 * Returns positive value if `p` lies inside the circle passing through a,b,c.
 * Returns negative value if `p` is outside and zero if all 4 points are
 * cocircular.
 *
 * @remarks
 * Assumes a,b,c are in ccw order or else result will be have inverted sign.
 *
 * Based on Jonathan R. Shewchuck:
 * http://www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c
 *
 * Also see {@link pointInCircumCircle}
 *
 * @param p -
 * @param a -
 * @param b -
 * @param c -
 */
export declare const pointIn3Circle: FnU4<ReadonlyVec, number>;
/**
 * Returns positive value if `p` lies inside the sphere passing through `a`,
 * `b`, `c`, `d`. Returns a negative value if `p` is outside and zero if all 5
 * points are cospherical.
 *
 * @remarks
 * Assumes a,b,c,d are in ccw order or else result will be have inverted sign.
 *
 * Based on Jonathan R. Shewchuck:
 * http://www.cs.cmu.edu/afs/cs/project/quake/public/code/predicates.c
 *
 * @param p -
 * @param a -
 * @param b -
 * @param c -
 * @param d -
 */
export declare const pointIn4Sphere: FnU5<ReadonlyVec, number>;
/**
 * Returns true if point `p` is in the circumcircle of triangle defined by `a`,
 * `b`, `c`.
 *
 * @param p
 * @param a
 * @param b
 * @param c
 */
export declare const pointInCircumCircle: FnU4<ReadonlyVec, boolean>;
/**
 * Returns true if point `p` is in the triangle defined by `a`, `b`, `c`.
 * @param p
 * @param a
 * @param b
 * @param c
 */
export declare const pointInTriangle2: FnU4<ReadonlyVec, boolean>;
/**
 * Returns a classifier for given point `p` with respect to the triangle defined
 * by `a`, `b`, `c`. Returns -1 if point is outside the triangle, 0 if on the
 * boundary (using `eps` as tolerance) or +1 if the point is inside.
 *
 * @remarks
 * Also see {@link pointInTriangle2}
 *
 * @param p
 * @param a
 * @param b
 * @param c
 * @param eps
 */
export declare const classifyPointInTriangle2: (p: ReadonlyVec, a: ReadonlyVec, b: ReadonlyVec, c: ReadonlyVec, eps?: number) => 0 | 1 | -1;
/**
 * Returns true if point `p` is inside the polygon boundary defined by `pts`.
 *
 * @param p
 * @param pts
 */
export declare const pointInPolygon2: (p: ReadonlyVec, pts: ReadonlyVec[]) => number;
/**
 * Returns a classifier for given point `p` with respect to the polygon defined
 * by `points`. Returns -1 if point is outside the polygon, 0 if on the boundary
 * (using `eps` as tolerance) or +1 if the point is inside.
 *
 * @param p
 * @param pts
 * @param eps
 */
export declare const classifyPointPolygon: (p: ReadonlyVec, pts: ReadonlyVec[], eps?: number) => 0 | 1 | -1;
/**
 * Helper function for {@link pointInPolygon2} to check point against a single
 * edge of the polygon boundary.
 *
 * @param px
 * @param py
 * @param ax
 * @param ay
 * @param bx
 * @param by
 * @param inside
 *
 * @internal
 */
export declare const checkPolyPair: FnN7;
/**
 * Similar to {@link checkPolyPair}, but also considering the case that `p` lies
 * on the line segment `a` -> `b` (with tolerance `eps`). Returns 0 if that is
 * the case, otherwise -2 if inside, or -1 if outside.
 *
 * @param px
 * @param py
 * @param ax
 * @param ay
 * @param bx
 * @param by
 * @param inside
 * @param eps
 *
 * @internal
 */
export declare const classifyPolyPair: (px: number, py: number, ax: number, ay: number, bx: number, by: number, inside: number, eps?: number) => number;
/**
 * Returns a classifier for given point `p` with respect to the plane defined by
 * `normal` and `w` (plane normal form). Returns -1 if point is below the plane,
 * 0 if on the plane (using `eps` as tolerance) or +1 if the point is above.
 *
 * @param p
 * @param normal
 * @param w
 * @param eps
 */
export declare const classifyPointPlane: (p: ReadonlyVec, normal: ReadonlyVec, w: number, eps?: number) => 0 | 1 | -1;
export declare const pointInBox: MultiVecOpImpl<Fn3<ReadonlyVec, ReadonlyVec, ReadonlyVec, boolean>>;
export declare const pointInRect: Fn3<ReadonlyVec, ReadonlyVec, ReadonlyVec, boolean>;
export declare const pointInAABB: Fn3<ReadonlyVec, ReadonlyVec, ReadonlyVec, boolean>;
export declare const pointInCenteredBox: MultiVecOpImpl<Fn3<ReadonlyVec, ReadonlyVec, ReadonlyVec, boolean>>;
export declare const pointInCenteredRect: Fn3<ReadonlyVec, ReadonlyVec, ReadonlyVec, boolean>;
export declare const pointInCenteredAABB: Fn3<ReadonlyVec, ReadonlyVec, ReadonlyVec, boolean>;
//# sourceMappingURL=point.d.ts.map